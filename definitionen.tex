\section{Definitionen}

Das Definitions-Kapitel wurde auf Grundlage von~\cite{Vogler2015FailSem}
und~\cite{Schinko2016BA} zusammengestellt und teilweise
von~\cite{Vogler2016MIA3} beeinflusst.

\begin{Def}[Modal Error-I/O-Transitionssystem]
  Ein \emph{Modales Error-I/O-Transitionssystem (\MEIO{})} ist ein Tupel
  $(P,I,O,\must,\may,p_0,E)$ mit:
  \begin{itemize}
    \item $P$: Menge der \emph{Zustände},
    \item $p_0\in P$: \emph{Startzustand},
    \item $I,O$: disjunkte Mengen der (sichtbaren) \emph{Input-} und
      \emph{Output-Aktionen},
    \item $\must{} \subseteq P\times \Sigma_{\tau}\times P$:
      \emph{must-Transitions-Relation},
    \item $\may{} \subseteq P\times \Sigma_{\tau}\times P$:
      \emph{may-Transitions-Relation},
    \item $E\subseteq P$: Menge der \emph{Fehler-Zustände}.
  \end{itemize}
  Es wird vorausgesetzt, dass $\must\subseteq\may$ (\emph{syntaktische
  Konsistenz}) gilt.\\
  Das \emph{Alphabet} bzw.\ die Aktionsmenge eines \MEIO{} ist $\Sigma = I\cup
  O$. Die \emph{interne Aktion} $\tau$ ist nicht in $\Sigma$ enthalten. Jedoch
  wird $\Sigma_{\tau} := \Sigma \cup \{\tau\}$ definiert. Die \emph{Signatur}
  eines \MEIO{}s entspricht $\Sig (P)=(I,O)$.\\
  Falls $\must =\may$ gilt, wird $P$ auch \emph{Implementierung} genannt.
\end{Def}

Implementierungen entsprechen den z.B.\ in~\cite{Schinko2016BA} behandelten
\EIO{}s.\\
Must-Transitionen sind Transitionen, die von einer Verfeinerung implementiert
werden müssen. Die may-Transitionen sind hingegen die zulässigen Transitionen
für eine Verfeinerung. Alle nicht vorhandenen must- und may-Transitionen dürfen
auch in keiner Verfeinerung einer Spezifikation in \MEIO{}-Form auftauchen.
Diese Forderungen werden in den Definitionen der Verfeinerungen in~\ref{SimDef}
und~\ref{wSimDef} berücksichtigt.\\
\MEIO{}s  werden in dieser Arbeit durch ihre Zustandsmenge (z.B.\ $P$)
identifiziert und falls notwendig werden damit auch die Komponenten indiziert
(z.B.\ $I_P$ anstatt $I$). Falls das \MEIO{} selbst bereits einen Index hat
(z.B.\ $P_1$) kann an der Komponente die Zustandsmenge als Index wegfallen und
nur noch der Index des gesamten Transitionssystems verwendet werden (z.B.\
$I_1$ anstatt $I_{P_1}$). Zusätzlich stehen $i,o,a,\omega$ und $\alpha$ für
Buchstaben aus den Alphabeten $I,O,\Sigma ,O\cup\{\tau\}$ und $\Sigma_\tau$.\\
Es wird die Notation $p\may[\alpha] p'$ für $(p,\alpha,p')\in\may$ und
$p\may[\alpha]$ für $\exists p':(p,\alpha,p')\in\may$ verwendet. Dies kann
entsprechend auf Buchstaben-Sequenzen $w\in\Sigma_{\tau}^*$ erweitert werden:
$p\may[w]p'$ ($p\may[w]$) steht für die Existenz eines \emph{Ablaufes}
$p\may[\alpha _1]p_1\may[\alpha _2]\dots p_{n-1}\may[\alpha _n] p'$
($p\may[\alpha _1] p_1 \may[\alpha _2]\dots p_{n-1}\may[\alpha _n]$) mit
$w=\alpha _1\dots \alpha _n$.\\
Desweiteren soll $w|_B$ die Aktions-Sequenz bezeichnen, die man erhält, wenn
man aus $w$ alle Aktionen löscht, die nicht in $B\subseteq\Sigma$ enthalten
sind. $\widehat{w}$ steht für $w|_{\Sigma}$. Es wird $p\weakmay[w] p'$
für ein $w\in\Sigma ^*$ geschrieben, falls $\exists
w'\in\Sigma_{\tau}^*:\widehat{w'}=w\land p\may[w']p'$, und $p\weakmay[w]$,
falls $p\weakmay[w] p'$ für ein beliebiges $p'$ gilt. Falls $p_0\weakmay[w] p$
gilt, dann wird $w$ \emph{Trace} genannt und $p$ ist ein \emph{erreichbarer
Zustand}.\\
Analog zu $\may$ und $\weakmay$ werden $\must$ und $\weakmust$ für die
entsprechenden Relationen der must-Transition verwendet.\\
Outputs und die interne Aktion werden \emph{lokale Aktionen} genannt, da sie
lokal vom ausführenden \MEIO{} kontrolliert sind.\\
Um die Notation zu vereinfachen soll $p\nmust[a]$ und $p\nmay[a]$ für
$\neg\exists p': p\must[a]p'$ und $\neg\exists p': p\may[a]p'$ stehen.
$p\must[a]\weakmust[\varepsilon]p'$ wird geschrieben, wenn $p''$ existiert, so
dass $p\must[a]p''\weakmust[\varepsilon]p'$ gilt. Diese Transition wird auch
als \emph{schwach-nachlaufende must-Transition} bezeichnet. Entsprechend steht
$\may[a]\weakmay[\varepsilon]$ für die \emph{schwach-nachlaufende
may-Transition}.\\
In Grafiken wird eine Aktion $a$ als $a?$ notiert, falls $a\in I$ und $a!$,
falls $a\in O$. Must-Transitionen (may-Transitionen) werden als durchgezogener
Pfeil gezeichnet (gestrichelter Pfeil). Entsprechend der syntaktischen
Konsistenz repräsentiert jede gezeichnete must-Transition auch gleichzeitig die
zugrundeliegende may-Transitionen.

\begin{Def}[Parallelkomposition]
  \label{ParallelDef}
  Zwei \MEIO{}s $P_1 = (P_1,I_1,O_1,{\must_1,}{\may_1,}$ $p_{01},E_1)$ und $P_2 =
  (P_2,I_2,O_2,\must_2,\may_2,p_{02},E_2)$ sind \emph{komponierbar}, falls
  $O_1\cap O_2=\emptyset$. Für solche \MEIO{}s ist die
  \emph{Parallelkomposition} $P_{12} := P_1\|P_2=((P_1\times P_2), I, O,
  {\must_{12},}$ ${\may_{12},}$ $(p_{01}, p_{02}), E)$ definiert mit:
  \TODO{erzwungenen Zeilenumbrüche kontrollieren}
  \begin{itemize}
    \item $I=(I_1\cup I_2)\backslash (O_1\cup O_2)$,
    \item $O=(O_1\cup O_2)$,
  \item $\begin{aligned}[t]
      \must_{12} & = \left\{\left((p_1,p_2),\alpha,(p_1',p_2)\right) \mid p_1
      \must[\alpha]_1 p_1', \alpha\in\Sigma_{\tau}\backslash
      \Synch(P_1,P_2)\right\}\\
        &\cup \left\{\left((p_1,p_2),\alpha,(p_1,p_2')\right) \mid p_2
      \must[\alpha]_2 p_2', \alpha\in\Sigma_{\tau}\backslash
      \Synch(P_1,P_2)\right\}\\
        &\cup \left\{\left((p_1,p_2),\alpha,(p_1',p_2')\right) \mid p_1
      \must[\alpha]_1 p_1', p_2 \must[\alpha]_2 p_2', \alpha\in
      \Synch(P_1,P_2)\right\},
    \end{aligned}$
  \item $\begin{aligned}[t]
      \may_{12} & = \left\{\left((p_1,p_2),\alpha,(p_1',p_2)\right) \mid p_1
      \may[\alpha]_1 p_1', \alpha\in\Sigma_{\tau}\backslash
      \Synch(P_1,P_2)\right\}\\
        &\cup \left\{\left((p_1,p_2),\alpha,(p_1,p_2')\right) \mid p_2
      \may[\alpha]_2 p_2', \alpha\in\Sigma_{\tau}\backslash
      \Synch(P_1,P_2)\right\}\\
        &\cup \left\{\left((p_1,p_2),\alpha,(p_1',p_2')\right) \mid p_1
      \may[\alpha]_1 p_1', p_2 \may[\alpha]_2 p_2', \alpha\in
      \Synch(P_1,P_2)\right\},
    \end{aligned}$
  \item $\begin{aligned}[t]
      E & = \left.(P_1\times E_2) \cup (E_1\times P_2)\hspace{3.95cm}\right\}
      &&\text{geerbte Fehler}\\
        &\left.\begin{aligned}
        \cup \left\{(p_1,p_2) \mid \exists a \in O_1\cap I_2 : p_1
        \may[a]_1\land p_2\nmust[a]_2\right\}\\
        \cup \left\{(p_1,p_2) \mid \exists a\in I_1\cap O_2 :
        p_1\nmust[a]_1\land p_2\may[a]_2\right\}
        \end{aligned}\hspace{0.2cm}\right\} &&\text{neue Kommunikationsfehler}.
    \end{aligned}$
  \end{itemize}
  Dabei bezeichnet $\Synch(P_1,P_2)=(I_1\cap O_2)\cup (O_1\cap I_2)\cup
  (I_1\cap I_2)$ die Menge der zu \emph{synchronisierenden Aktionen}. Die
  synchronisierten Aktionen werden zu Inputs (im Fall $(I_1\cap I_2)$) bzw.
  Outputs (alle anderen Fälle) der Komposition.\\
  $P_1$ ist ein \emph{Partner} von $P_2$, wenn $P_1$ und $P_2$ duale Signaturen
  $\Sig (P_1)=(I,O)$ und $\Sig (P_2)=(O,I)$ haben.
\end{Def}

Die Definition der Parallelkomposition sagt aus, dass ein neuer Fehler
entsteht, wenn eines der \MEIO{}s die Möglichkeit für einen Output hat
(may-Transition) und das andere \MEIO{} den passenden Input nicht sicher stellt
(keine must-Transition vorhanden). Es muss also in möglichen Implementierungen
nicht wirklich zu diesem Fehler kommen, da die Output"=Transition nicht
zwingendermaßen implementiert werden muss und die may"=Input"=Transition
trotzdem erlaubt sein kann.\\
Durch die Synchronisation von Inputs kann es zu keinen neuen Fehler kommen, da
die Inputs in beiden Transitionssystemen keine lokal kontrollierten Aktionen
sind. Falls jedoch nur eines der Transitionssysteme einen Input sicherstellt,
der synchronisiert wird, wird dieser Input in der Parallelkomposition nicht
mehr sicher gestellt. Es kann also in der Kommunikation mit einem weiteren
\MEIO{} dort zu einem neuen Fehler kommen.

\begin{Def}[alternierende Simulation]
  \label{SimDef}
  Eine Relation $\mathcal{R}\subseteq P \times Q$ auf zwei \MEIO{}s $P$ und $Q$
  mit gleicher Signatur ist eine \emph{(starke) alternierende Simulation}, wenn
  für alle $(p,q)\in \mathcal{R}$ mit $q\notin E_Q$ und alle $\alpha\in\Sigma
  _\tau$ gilt:
  \begin{enumerate}
    \item $p\notin E_P$,
    \item falls $q\must[\alpha]_Q q'$ gilt, gibt es eine Transition
      $p\must[\alpha]_P p'$ für ein $p'$ mit $p'\mathcal{R}q'$,
    \item falls $p\may[\alpha]_P p'$ gilt, gibt es eine Transition
      $q\may[\alpha]_Q q'$ für ein $q'$ mit $p'\mathcal{R}q'$.
  \end{enumerate}
  Die Vereinigung \asRel{} aller dieser Simulations-Relationen wird als
  \emph{(starke) as-Verfeinerung(-s Relation)} (auch modal Verfeinerung)
  bezeichnet. Falls für die Startzustände von zwei \MEIO{}s $p_0\asRel q_0$
  gilt, wird auch $P\asRel Q$ für die Transitionssysteme geschrieben. $P\asRel
  Q$ bedeutet, dass $P$ $Q$ \emph{(stark) as-verfeinert} oder dass $P$ eine
  \emph{(starke) as-Verfeinerung} von $Q$ ist.\\
  Für ein \MEIO{} $Q$ und eine Implementierung $P$ mit $P\asRel{}Q$, ist
  $P$ eine \emph{as"=Implementierung} von $Q$ und es wird $\asimp (Q)$ für die
  Menge aller as"=Implementierungen von $Q$ verwendet.
\end{Def}

Da für zwei \MEIO{}s $P$ und $Q$ und alle möglichen Zustands-Tupel $(p,q)$ in
einer alternierenden Simulations-Relation $\mathcal{R}$ gelten muss, dass aus
$q\notin E_Q$ folgt, dass auch $p$ nicht in $E_P$ enthalten ist, gilt auch die
Implikation $p\in E_P\Rightarrow q\in E_Q$.\\
Für LTS (Labelled Transition Systems), die nach Definition keine Modalitäten
und keine Fehler-Zustände enthalten, entspricht die as"=Verfeinerung einer
Bisimulation. Dafür müssen die Transitionen eines LTS als must"=Transitionen
aufgefasst werden. Man kann also auf LTS mit einer as"=Verfeinerungs"=Relation
zwischen zwei Systemen deren Äquivalenz beweisen. Man muss dazu einen
Äquivalenz Begriff wie in~\cite{Milner1989} verwenden.\\
Auf den \EIO{}, die z.B.\ in~\cite{Schinko2016BA} betrachtet wurden, lässt die
as"=Verfeinerungs"=Relation zu, dass es in einer Verfeinerung möglicherweise
weniger Fehler gibt und zusätzliches Verhalten, dass die Spezifikation nicht
hatte. Die \EIO{}s entsprechen Implementierungen von \MEIO{}s, es ist also
möglich, eine Implementierung mit Fehler durch eine andere as zu verfeinern,
die keine Fehler enthält, aber potentiell zusätzliches Verhalten aufweist.
Siehe hierzu auch das Beispiel in Abbildung~\ref{ImplVerfBsp}. Die
Implementierung $P$ ist eine Verfeinerung der Implementierung $Q$ und
zwischen ihnen erfüllt die as"=Verfeinerung"=Relation $\mathcal{R} =
\{(p_0,q_0)\}$ die Definition~\ref{SimDef}. $P$ verfeinert den Fehler"=Zustand
von $Q$ nicht mit einem Fehler sondern durch die $o$ Schlinge.\\
Falls eine Implementierung bereits frei von Fehler"=Zuständen ist, entspricht
sie einem LTS und kann somit nur noch durch äquivalente Implementierungen \glqq
verfeinert\grqq{} werden.

\begin{figure}[htbp]
  \begin{center}
    \begin{tikzpicture}[->, >=latex', auto,node distance=2.5cm, semithick]
      \node [initial,initial text=$P$:] (p0) at (0,0) {$p_0$};

      \path
      (p0) edge[loop right] node{$o!$} (p0)
      ;

      \node [initial,initial text=$Q$:, draw, rectangle] (q0) at (6,0) {$q_0 \in E_Q$};
    \end{tikzpicture}
    \caption{Beispiel für die Verfeinerung von Implementierungen}
    \label{ImplVerfBsp}
  \end{center}
\end{figure}

\begin{Def}[schwache alternierende Simulation]
  \label{wSimDef}
  Eine Relation $\mathcal{R} \subseteq P  \times Q$ auf zwei \MEIO{}s $P$ und
  $Q$ mit gleicher Signatur ist eine \emph{schwache alternierende Simulation},
  wenn für alle $(p,q) \in \mathcal{R}$ mit $q\notin E_Q$ und $i\in I$ und
  $\omega\in O\cup\{\tau\}$ gilt:
  \begin{enumerate}
    \item $p\notin E_P$,
    \item falls $q\must[i]_Q q'$ gilt, gibt es eine Transition $p \must[i]_P
      \weakmust[\varepsilon]_P p'$ für ein $p'$ mit $p'\mathcal{R}q'$,
    \item falls $q\must[\omega]_Q q'$ gilt, gibt es eine Transition $p
      \weakmust[\hat{\omega}]_P p'$ für ein $p'$ mit $p'\mathcal{R}q'$,
    \item falls $p\may[i]_P p'$ gilt, gibt es eine Transition $q
      \may[i]_Q\weakmay[\varepsilon]_Q q'$ für ein $q'$ mit $p'\mathcal{R}q'$,
    \item falls $p\may[\omega]_P p'$ gilt, gibt es eine Transition $q
      \weakmay[\hat{\omega}]_Q q'$ für ein $q'$ mit $p'\mathcal{R}q'$.
  \end{enumerate}
  Analog zur starken alternierenden Simulation, wird hier \wasRel{} als
  Relationssymbol für die Vereinigung aller schwachen Simulations-Relationen
  verwendet und man kann auch entsprechend \emph{schwache as"=Verfeinerungen}
  definieren.\\
  Für ein \MEIO{} $Q$ und eine Implementierung $P$ mit $P\wasRel Q$, ist $P$
  eine \emph{w"=as"=Implementierung} von $Q$ und es wird $\wasimp (Q)$ für die
  Menge aller w"=as"=Implementierungen von $Q$ verwendet.
\end{Def}

Die schwache Simulation erlaubt interne Aktionen des \MEIO{}, das eine Aktion
matchen muss. Jedoch ist es zwingend notwendig, dass ein Input sofort
ausgeführt wird und erst dann interne Aktinen möglich sind, da ein Input die
Reaktion auf eine Aktion ist, die die Umwelt auslöst, welche nicht auf das
Transitionssystem warten kann. Outputs hingegen können auch verzögert werden,
da die Umgebung diese dann als Inputs aufnimmt und für die Umgebung diese
Aktionen nicht lokal kontrolliert sind.\\
Auch für alle Tupel $(p,q)$ in einer schwach alternierenden
Simulations-Relation $\mathcal{R}$ gilt $p\in E_P\Rightarrow q\in E_Q$.

Wie üblich kann man zeigen, dass \asRel{} (bzw.\ \wasRel{}) eine starke (bzw.\
schwache) alternierende Simulation ist und die Eigenschaft der Transitivität
erfüllt. Die Beweise für diese Aussagen sollen hier entfallen.

Die in der folgende Definition vorgestellte Parallelkomposition von Wörtern und
Mengen kann z.B.\ aus~\cite{Vogler2014EIO} übernommen werden.

\begin{Def}[Parallelkomposition auf Traces]\mbox{}
  \begin{itemize}
    \item Für zwei Wörter $w_1\in\Sigma _1$ und $w_2\in\Sigma _2$ ist
      deren Parallelkomposition definiert als: $w_1\| w_2:=\left\{w\in
      (\Sigma _1\cup\Sigma _2)^*\mid w|_{\Sigma _1}=w_1\wedge w|_{\Sigma
    _2}=w_2\right\}$.
    \item Für zwei Mengen von Wörtern bzw. Sprachen $W_1\subseteq \Sigma
      ^*_1$ und $W_2\subseteq \Sigma ^*_2$ ist deren Parallelkomposition
      definiert als: $W_1\| W_2:=\bigcup\hspace{1pt}\left\{w_1\| w_2\mid
      w_1\in W_1\wedge w_2\in W_2\right\}$.
  \end{itemize}
\end{Def}

Die Wörter $w_1$ und $w_2$ sind für gewöhnlich Traces von \MEIO{}, die
Komponiert werden. Das Wort $w_1\|w_2$ ist dann eine Aktionsfolge aus Input und
Outputs. Es existiert in einer Parallelkomposition ein Transitionsfolge vom
Startzustand aus, die mit den Aktionen aus $w\in w_1\|w_2$ beschriftet ist. Der
Trace $w_1\|w_2$ der Parallelkomposition kann also auch als Wort aufgefasst
werden, dass verarbeitet wird während es Ablauf des Systems.

Definitionen der Funktionen \prune{} und \cont{} zum Abschneiden und Verlängern
von Traces können ebenso wie die letzte Definition aus
z.B.~\cite{Vogler2014EIO} übernommen werden. Hierbei ist zu beachten, dass in
dieser Arbeit $\varepsilon$ das leere Wort und $\mathfrak{P}(M)$ die
Potenzmenge der Menge $M$ bezeichnet.

\begin{Def}[Pruning- und Fortsetzungs-Funktion]\mbox{}
  \begin{itemize}
    \item $\prune{}:\Sigma ^*\rightarrow\Sigma ^*, w\mapsto u$, mit $w=uv,
      u=\varepsilon\vee u\in\Sigma ^*\cdot I$ und $v\in O^*$,
    \item $\cont{}:\Sigma ^*\rightarrow\mathfrak{P}(\Sigma ^*),
      w\mapsto\left\{wu\mid u\in\Sigma ^*\right\}$,
    \item $\cont{}:\mathfrak{P}(\Sigma ^*)\rightarrow\mathfrak{P}(\Sigma ^*),
      L\mapsto\bigcup\hspace{1pt}\left\{\cont{}(w)\mid w\in L\right\}$.
  \end{itemize}
\end{Def}

\vspace{0.2cm}

\begin{Def}[Sprache]
  \label{LDef}
  Die \emph{Sprache} eines \MEIO{}s $P$ ist definiert als:
  \[L(P) := \left\{w\in \Sigma ^* \mid p_0\weakmay[w]_P \right\}.\]
\end{Def}

Somit entspricht die Sprache einer Implementierung der Definition
aus~\cite{Schinko2016BA} für \EIO{}s. Jedoch muss die Sprache einer
as"=Verfeinerung eines \MEIO{}s nicht mehr Teilmenge der Sprache des \MEIO{}s
sein, da Definition~\ref{SimDef} beliebiges Verhalten nach einem Fehler-Zustand
in dem zu verfeinernden \MEIO{} zulässt. Falls jedoch das \MEIO{} bereits frei
von Fehler"=Zuständen ist, ist seine Sprache die Vereinigung der Sprachen all
seine möglichen as"=Implementierungen.\\
Von der Sprache einer as"=Verfeinerung eines \MEIO{}s kann man nur wenig
Rückschlüsse auf die ursprüngliche Sprache ziehen, da man nicht weiß,
welche Fehler-Zustände in der Verfeinerung übernommen wurden und welche als
normale Zustände mit beliebigen Verhalten umgesetzt wurden.\\
Man hätte alternativ die Sprache eines \MEIO{}s auf andere Weise definieren
können um einen eindeutigen Zusammenhang zwischen dieser und den Sprachen der
as"=Implementierungen zu erhalten, jedoch wäre dann die Äquivalenz zur \EIO{}
Sprach-Definition in~\cite{Schinko2016BA} verloren gegangen. Eine
Implementierung mit Fehler-Zuständen hätte dann eine Sprache mit Wörtern, die
sie nicht ausführen können muss.

Im folgenden soll ein Operator wie in z.B.~\ref{Vogler2016MIA3}
und~\ref{Schinko2016BA} definiert werden um Aktionen zu verbergen, dieses
vorgehen wird Hiding genannt. Da nur die Outputs vom jeweiligen System
kontrolliert sind, werden diese durch das verbergen als interne Aktionen
trotzdem ausgeführt, nur nach außen hin nicht mehr sichtbar. Input werden
hingeben ausgeführt, wenn die Umgebung das passenden Signal sendet. Wenn man
Input verbergen würde, schließt man dadurch den Kommunikationskanal und
blockiert die Kommunikation mit anderen Systemen, die den passenden Output
besitzen. Das verbergen von Input verbietet die entsprechend beschrifteten
Transitionen, ähnlich wie der der Anwendung von Restriktionen in CCS
in~\cite{Milner1989}. Dies würde jedoch die Transitionssysteme zu stark
einschränken und soll deshalb hier nicht betrachtet werden. Der Hiding-Operator
wird hier somit nur für Output-Aktionen definiert werden wie in
z.B.~\ref{Schinko2016BA}.

\begin{Def}[Hiding-Operator]
  Für einen \MEIO{} $P = (P,I_P,O_P,\must _P, \may _P, p_{0_P}, E_P)$ ist
  $P/X$, mit dem Hiding-Operator $\cdot /\cdot$, definiert als der \MEIO{}
  $P/X$ mit:
  \begin{itemize}
    \item $\tau \notin X$,
    \item $X\cap I = \emptyset$,
    \item $P/X = P$, $I_{P/X} = I_P$, $p_{0_{P/X}} = p_{0_P}$ und $E_{P/X} =
      E_P$,
    \item $\must _{P/X} = (\must _P \cup \{(p,\tau,p')\mid (p,o,p')\in \must
      _P, o \in X\})\backslash \{(p,o,p')\mid (p,o,p')\in \must _P, o \in X\}$,
    \item $\may _{P/X} = (\may _P \cup \{(p,\tau,p')\mid (p,o,p')\in \may _P, o
      \in X\})\backslash \{(p,o,p')\mid (p,o,p')\in \may _P, o \in X\}$.
  \end{itemize}
\end{Def}

Die Transitionen, die mit einem Outputs beschriftet sind, der in der Menge $X$
der zu verbergenden Aktionen enthalten ist, werden durch das Hiding zu internen
Transitionen. Die Transitionen sind also weiterhin lokal kontrolliert
ausführbar. Auch für schwache must- und may"=Transtionen ändert sich nur die
Beschriftung, jedoch nicht die Ausführbarkeit.
