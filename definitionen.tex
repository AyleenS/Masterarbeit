\chapter{Definitionen}
{\large\textbf{Stand: \today{}}}\\

Das Definitions-Kapitel wurde auf Grundlage von~\cite{Vogler2015FailSem}
und~\cite{Schinko2016BA} zusammengestellt und teilweise
von~\cite{Vogler2016MIA3} beeinflusst.

\begin{Def}[Modal Error-I/O-Transitionssystem]
  Ein \emph{Modal Error-I/O-Transitionssystem (\MEIO{})} ist ein Tupel
  $(P,I,O,\must,\may,p_0,E)$ mit:
  \begin{itemize}
    \item $P$: Menge der \emph{Zustände},
    \item $p_0\in P$: \emph{Startzustand},
    \item $I,O$: disjunkte Mengen der (sichtbaren) \emph{Input-} und
      \emph{Output-Aktionen},
    \item $\must{} \subseteq P\times \Sigma_{\tau}\times P$:
      \emph{must-Transitions-Relation},
    \item $\may{} \subseteq P\times \Sigma_{\tau}\times P$:
      \emph{may-Transitions-Relation},
    \item $E\subseteq P$: Menge der \emph{Fehler-Zustände}.
  \end{itemize}
  Es wird vorausgesetzt, dass $\must\subseteq\may$ (\emph{syntaktische
  Konsistenz}) gilt.\\
  Das \emph{Alphabet} bzw.\ die Aktionsmenge eines \MEIO{} ist $\Sigma = I\cup
  O$. Die \emph{interne Aktion} $\tau$ ist nicht in $\Sigma$ enthalten. Jedoch
  wird $\Sigma_{\tau} := \Sigma \cup \{\tau\}$ definiert. Die \emph{Signatur}
  eines \MEIO{}s entspricht $\Sig (P)=(I,O)$.\\
  Falls $\must =\may$ gilt, wird $P$ auch \emph{Implementierung} genannt.
\end{Def}

Implementierungen entsprechen den z.B.\ in~\cite{Schinko2016BA} behandelten
\EIO{}s.\\
Must-Transitionen sind Transitionen, die von einer Verfeinerung implementiert
werden müssen. Die may-Transitionen sind hingegen die zulässigen Transitionen
für eine Verfeinerung. Alle nicht vorhandenen Transitionen dürfen auch in
keiner Verfeinerung einer Spezifikation in \MEIO{}-Form auftauchen.\\
\MEIO{}s  werden in dieser Arbeit durch ihre Zustandsmenge (z.B.\ $P$)
identifiziert und falls notwendig werden damit auch die Komponenten indiziert
(z.B.\ $I_P$ anstatt $I$). Falls das \MEIO{} selbst bereits einen Index hat
(z.B.\ $P_1$) kann an der Komponente die Zustandsmenge als Index wegfallen und
nur noch der Index des gesamten Transitionssystems verwendet werden (z.B.\
$I_1$ anstatt $I_{P_1}$). Zusätzlich stehen $i,o,a,\omega$ und $\alpha$ für
Buchstaben aus den Alphabeten $I,O,\Sigma ,O\cup\{\tau\}$ und $\Sigma_\tau$.\\
Es wird die Notation $p\may[\alpha] p'$ für $(p,\alpha,p')\in\may$ und
$p\may[\alpha]$ für $\exists p':(p,\alpha,p')\in\may$ verwendet. Dies kann
entsprechend auf Buchstaben-Sequenzen $w\in\Sigma_{\tau}^*$ erweitert werden:
für $p\may[w]p'$ ($p\may[w]$) steht für die Existenz eines Laufes $p\may[\alpha
_1]p_1\may[\alpha _2]\dots p_{n-1}\may[\alpha _n] p'$ ($p\may[\alpha _1] p_1
\may[\alpha _2]\dots p_{n-1}\may[\alpha _n]$) mit $w=\alpha _1\dots \alpha
_n$.\\
Desweiteren soll $w|_B$ die Aktions-Sequenz bezeichnen, die man erhält, wenn
man aus $w$ alle Aktionen löscht, die nicht in $B\subseteq\Sigma$ enthalten
sind. $\widehat{w}$ steht für $w|_{\Sigma}$. Es wird $p\weakmay[w] p'$
für ein $w\in\Sigma ^*$ geschrieben, falls $\exists
w'\in\Sigma_{\tau}^*:\widehat{w'}=w\land p\may[w']p'$, und $p\weakmay[w]$,
falls $p\weakmay[w] p'$ für ein beliebiges $p'$ gilt. Falls $p_0\weakmay[w] p$
gilt, dann wird $w$ \emph{Trace} genannt und $p$ ist ein \emph{erreichbarer
Zustand}.\\
Analog zu $\may$ und $\weakmay$ werden $\must$ und $\weakmust$ für die
entsprechenden Relationen der must-Transition verwendet.\\
Outputs und die interne Aktion werden \emph{lokale Aktionen} genannt, da sie
lokal vom ausführenden \MEIO{} kontrolliert sind.\\
Um eine Erleichterung der Notation zu erhalten, soll gelten, dass $p\nmust[a]$
und $p\nmay[a]$ für $\neg\exists p': p\must[a]p'$ und $\neg\exists p':
p\may[a]p'$ stehen soll. $p\must[a]\weakmust[\varepsilon]p'$ wird geschrieben,
wenn $p''$ existiert, so dass $p\must[a]p''\weakmust[\varepsilon]p'$ gilt.
Diese Transition wird auch als \emph{schwach-nachlaufende must-Transition}
bezeichnet. Entsprechend steht $\may[a]\weakmay[\varepsilon]$ für die
\emph{schwach-nachlaufende may-Transition}.\\
In Graphiken wird eine Aktion $a$ als $a?$ notiert, falls $a\in I$ und $a!$,
falls $a\in O$. Must-Transitionen (may-Transitionen) werden als durchgezogener
Pfeil gezeichnet (gestrichelter Pfeil). Entsprechend der syntaktischen
Konsistenz repräsentiert jede gezeichnete must-Transition auch gleichzeitig die
zugrundeliegende may-Transitionen.

\begin{Def}[Parallelkomposition]
  \label{ParallelDef}
  Zwei \MEIO{}s $P_1 = (P_1,I_1,O_1,{\must_1,}{\may_1,}$ $p_{01},E_1)$ und $P_2 =
  (P_2,I_2,O_2,\must_2,\may_2,p_{02},E_2)$ sind \emph{komponierbar}, falls
  $O_1\cap O_2=\emptyset$. Für solche \MEIO{}s ist die
  \emph{Parallelkomposition} $P_{12} := P_1\|P_2=((P_1\times P_2), I, O,
  {\must_{12},}$ ${\may_{12},}$ $(p_{01}, p_{02}), E)$ definiert mit:
  \TODO{erzwungenen Zeilenumbrüche kontrollieren}
  \begin{itemize}
    \item $I=(I_1\cup I_2)\backslash (O_1\cup O_2)$,
    \item $O=(O_1\cup O_2)$,
  \item $\begin{aligned}[t]
      \must_{12} & = \left\{\left((p_1,p_2),\alpha,(p_1',p_2)\right) \mid p_1
      \must[\alpha]_1 p_1', \alpha\in\Sigma_{\tau}\backslash
      \Synch(P_1,P_2)\right\}\\
        &\cup \left\{\left((p_1,p_2),\alpha,(p_1,p_2')\right) \mid p_2
      \must[\alpha]_2 p_2', \alpha\in\Sigma_{\tau}\backslash
      \Synch(P_1,P_2)\right\}\\
        &\cup \left\{\left((p_1,p_2),\alpha,(p_1',p_2')\right) \mid p_1
      \must[\alpha]_1 p_1', p_2 \must[\alpha]_2 p_2', \alpha\in
      \Synch(P_1,P_2)\right\},
    \end{aligned}$
  \item $\begin{aligned}[t]
      \may_{12} & = \left\{\left((p_1,p_2),\alpha,(p_1',p_2)\right) \mid p_1
      \may[\alpha]_1 p_1', \alpha\in\Sigma_{\tau}\backslash
      \Synch(P_1,P_2)\right\}\\
        &\cup \left\{\left((p_1,p_2),\alpha,(p_1,p_2')\right) \mid p_2
      \may[\alpha]_2 p_2', \alpha\in\Sigma_{\tau}\backslash
      \Synch(P_1,P_2)\right\}\\
        &\cup \left\{\left((p_1,p_2),\alpha,(p_1',p_2')\right) \mid p_1
      \may[\alpha]_1 p_1', p_2 \may[\alpha]_2 p_2', \alpha\in
      \Synch(P_1,P_2)\right\},
    \end{aligned}$
  \item $\begin{aligned}[t]
      E & = (P_1\times E_2) \cup (E_1\times P_2) &&\text{geerbte
        Fehler}\\
        &\left.\begin{aligned}
        \cup \left\{(p_1,p_2) \mid \exists a \in O_1\cap I_2 : p_1
        \may[a]_1\land p_2\nmust[a]_2\right\}\\
        \cup \left\{(p_1,p_2) \mid \exists a\in I_1\cap O_2 :
        p_1\nmust[a]_1\land p_2\may[a]_2\right\}
        \end{aligned}\hspace{0.2cm}\right\} &&\text{neue Kommunikationsfehler}.
    \end{aligned}$
  \end{itemize}
  Dabei bezeichnet $\Synch(P_1,P_2)=(I_1\cap O_2)\cup (O_1\cap I_2)\cup
  (I_1\cap I_2)$ die Menge der zu \emph{synchronisierenden Aktionen}. Die
  synchronisierten Aktionen werden als Inputs, in dem Fall $(I_1\cap I_2)$, bzw.
  Outputs, in allen anderen Fällen, der Komposition beibehalten.\\
  $P_1$ wird \emph{Partner} von $P_2$ genannt, wenn die Parallelkomposition von
  $P_1$ und $P_2$ geschlossen ist. Eine Parallelkomposition von zwei \MEIO{}s
  $P_1$ und $P_2$ ist \emph{geschlossen}, wenn $P_1$ und $P_2$ duale Signaturen
  $\Sig (P_1)=(I,O)$ und $\Sig (P_2)=(O,I)$ haben.
\end{Def}

Ein neuer Fehler entsteht, wenn eines der \MEIO{}s die
Möglichkeit für einen Output hat (may-Transition) und das andere \MEIO{} den
passenden Input nicht sicher stellt (keine must-Transition vorhanden). Es muss
also in möglichen Implementierungen nicht wirklich zu diesem
Fehler kommen, da die Output"=Transition nicht zwingendermaßen
implementiert werden muss und die may"=Input"=Transition trotzdem erlaubt sein
kann.\\
Wie bereits unter anderem in~\cite{Schinko2016BA} gesehen werden konnte, kann
es durch die Synchronisation von Inputs zu keinen neuen Fehler kommen, da die
Inputs in beiden Transitionssystemen keine lokal kontrollierten Aktionen sind.
Falls jedoch nur eines der Transitionssysteme die Möglichkeit für einen Input
hat, der synchronisiert wird, besteht diese Möglichkeit in der
Parallelkomposition nicht mehr. Es kann also in der Kommunikation mit einem
weiteren \MEIO{} dort zu einem neuen Fehler kommen.

\begin{Def}[alternierende Simulation]
  \label{SimDef}
  Eine \emph{(starke) alternierende Simulation} ist eine Relation
  $\mathcal{R}\subseteq P \times Q$ auf zwei \MEIO{}s $P$ und $Q$, wenn für
  alle $(p,q)\in \mathcal{R}$ mit $q\notin E_Q$ und $\alpha\in\Sigma _\tau$
  gilt:
  \begin{enumerate}
    \item $p\notin E_P$,
    \item $q\must[\alpha]_Q q'$ impliziert $p\must[\alpha]_P p'$ für ein $p'$
      mit $p'\mathcal{R}q'$,
    \item $p\may[\alpha]_P p'$ impliziert $q\may[\alpha]_Q q'$ für ein $q'$ mit
      $p'\mathcal{R}q'$.
  \end{enumerate}
  Die Vereinigung \asRel{} aller dieser Relationen wird als \emph{(starke)
  as-Verfeinerung(-s Relation)} (auch modal Verfeinerung) bezeichnet. Es wird
  $P\asRel Q$ geschrieben, falls $p_0\asRel q_0$ gilt. $P\asRel Q$ steht dabei
  dafür, dass $P$ $Q$ \emph{(stark) as-verfeinert} oder dass $P$ eine
  \emph{(starke) as-Verfeinerung} von $Q$ ist.\\
  Für ein \MEIO{} $Q$ und eine Implementierung $P$ mit $P\asRel{}Q$, ist
  $P$ eine \emph{as"=Implementierung} von $Q$ und es wird $\asimp (Q)$ für die
  Menge aller as"=Implementierungen von $Q$ verwendet.
\end{Def}

Da für zwei \MEIO{}s $P$ und $Q$ und alle möglichen Zustands-Tupel $(p,q)$ in
einer alternierenden Simulations-Relation $\mathcal{R}$ gelten muss, dass aus
$q\notin E_Q$ folgt, dass auch $p$ nicht in $E_P$ enthalten ist, gilt auch die
Implikation $p\in E_P\Rightarrow q\in E_Q$.\\
Für LTS, die nach Definition keine Modalitäten und keine Fehler-Zustände
enthalten, entspricht die as"=Verfeinerung einer Bisimulation. Dafür müssen die
Transitionen eines LTS als must"=Transitionen aufgefasst werden. Man kann also
auf LTS mit einer as"=Verfeinerungs"=Relation zwischen zwei Systemen deren
Äquivalenz beweisen.\\
Auf den \EIO{}, die z.B.\ in~\cite{Schinko2016BA} betrachtet wurden, lässt die
as"=Verfeinerungs"=Relation jedoch zu, dass es in einer Verfeinerung
möglicherweise weniger Fehler gibt und zusätzliches Verhalten, dass die
Spezifikation nicht hatte. Die \EIO{} entsprechend Implementierungen von
\MEIO{}s, es ist also möglich, eine Implementierung mit Fehler durch eine
andere as zu verfeinern, die keine Fehler enthält, aber potentiell zusätzliches
Verhalten aufweist.

\begin{Def}[schwache alternierende Simulation]
  \label{wSimDef}
  Eine \emph{schwache alternierende Simulation} ist eine Relation $\mathcal{R}
  \subseteq P  \times Q$ auf zwei \MEIO{}s $P$ und $Q$, wenn für alle $(p,q)
  \in \mathcal{R}$ mit $q\notin E_Q$ und $i\in I$ und $\omega\in O\cup\{\tau\}$
  gilt:
  \begin{enumerate}
    \item $p\notin E_P$,
    \item $q\must[i]_Q q'$ impliziert $p\must[i]_P\weakmust[\varepsilon]_P p'$
      für ein $p'$ mit $p'\mathcal{R}q'$,
    \item $q\must[\omega]_Q q'$ impliziert $p\weakmust[\hat{\omega}]_P p'$ für
      ein $p'$ mit $p'\mathcal{R}q'$,
    \item $p\may[i]_P p'$ impliziert $q\may[i]_Q\weakmay[\varepsilon]_Q q'$ für
      ein $q'$ mit $p'\mathcal{R}q'$,
    \item $p\may[\omega]_P p'$ impliziert $q\weakmay[\hat{\omega}]_Q q'$ für
      ein $q'$ mit $p'\mathcal{R}q'$.
  \end{enumerate}
  Analog zur starken alternierenden Simulation, wird hier \wasRel{} als
  Relationssymbol verwendet und man kann auch entsprechend \emph{schwache
  as"=Verfeinerungen} betrachten.\\
  Ebenso kann \wasRel{} für ein \MEIO{} Q und eine Implementierung $P$
  definiert werden mit $P\wasRel Q$, ist $P$ eine \emph{w"=as"=Implementierung}
  von $Q$ und es wird $\wasimp (Q)$ für die Menge aller
  w"=as"=Implementierungen von $Q$ verwendet.
\end{Def}

Die schwache Simulation erlaubt interne Aktionen beim \MEIO{}, das die
entsprechende Aktion matchen muss. Jedoch ist es zwingen notwendig, dass ein
Input sofort aufgeführt wird und erst dann interne Aktinen möglich sind. Da
ein Input die Reaktion auf eine Aktion ist, die die Umwelt auslöst und die
nicht auf das Transitionssystem warten kann. Outputs hingegen können auch
verzögert werden, da die Umgebung dies dann als Inputs aufnimmt und für diese
somit nicht lokal kontrolliert ist.\\
Auch für alle Tupel $(p,q)$ in einer schwach alternierenden
Simulations-Relation $\mathcal{R}$ gilt $p\in E_P\Rightarrow q\in E_Q$.

Die Parallelkomposition von Wörtern und Mengen kann z.B.\
aus~\cite{Vogler2014EIO} übernommen werden.

\begin{Def}[Parallelkomposition auf Traces]\mbox{}
  \begin{itemize}
    \item Für zwei Wörter $w_1\in\Sigma _1$ und $w_2\in\Sigma _2$ ist
      deren Parallelkomposition definiert als: $w_1\| w_2:=\left\{w\in
      (\Sigma _1\cup\Sigma _2)^*\mid w|_{\Sigma _1}=w_1\wedge w|_{\Sigma
    _2}=w_2\right\}$.
    \item Für zwei Mengen von Wörtern bzw. Sprachen $W_1\subseteq \Sigma
      ^*_1$ und $W_2\subseteq \Sigma ^*_2$ ist deren Parallelkomposition
      definiert als: $W_1\| W_2:=\bigcup\hspace{1pt}\left\{w_1\| w_2\mid
      w_1\in W_1\wedge w_2\in W_2\right\}$.
  \end{itemize}
\end{Def}

Ebenso können die Definitionen der Funktionen \prune{} und \cont{} zum
Abschneiden und Verlängern von Traces z.B.\ aus~\cite{Vogler2014EIO} übernommen
werden. Hierbei ist zu beachten, dass in dieser Arbeit $\varepsilon$ das leere
Wort und $\mathfrak{P}(M)$ die Potenzmenge der Menge $M$ bezeichnet.

\begin{Def}[Pruning- und Fortsetzungs-Funktion]\mbox{}
  \begin{itemize}
    \item $\prune{}:\Sigma ^*\rightarrow\Sigma ^*, w\mapsto u$, mit $w=uv,
      u=\varepsilon\vee u\in\Sigma ^*\cdot I$ und $v\in O^*$,
    \item $\cont{}:\Sigma ^*\rightarrow\mathfrak{P}(\Sigma ^*),
      w\mapsto\left\{wu\mid u\in\Sigma ^*\right\}$,
    \item $\cont{}:\mathfrak{P}(\Sigma ^*)\rightarrow\mathfrak{P}(\Sigma ^*),
      L\mapsto\bigcup\hspace{1pt}\left\{\cont{}(w)\mid w\in L\right\}$.
  \end{itemize}
\end{Def}

\vspace{0.2cm}

\begin{Def}[Sprache]
  \label{LDef}
  Die \emph{Sprache} eines \MEIO{}s $P$ ist definiert als: $L(P) := \left\{w\in
  \Sigma ^* \mid p_0\weakmay[w]_P \right\}$.
\end{Def}

Somit entspricht die Sprache eines \MEIO{}s, das eine Implementierung ist der
Definition aus~\cite{Schinko2016BA} für \EIO{}s. Jedoch muss die Sprache einer
as"=Verfeinerung eine \MEIO{}s nicht mehr Teilmenge der Sprache des
\MEIO{}s sein, da Definition~\ref{SimDef} beliebiges Verhalten nach einem
Fehler-Zustand in dem zu verfeinernden \MEIO{} zulässt. Falls jedoch der
\MEIO{} bereits fehler-frei ist, ist seine Sprache die Vereinigung der Sprachen
all seine möglichen as"=Implementierungen.\\
Von der Sprache einer as"=Verfeinerung eines \MEIO{}s kann man keine
Rückschlüsse mehr auf die ursprüngliche Sprache ziehen, da man nicht weiß,
welche Fehler-Zustände in der Verfeinerung übernommen wurden und welche als
normale Zustände mit beliebigen Verhalten umgesetzt wurden.\\
Man hätte alternativ die Sprache eines \MEIO{}s anders definieren können um
weiterhin einen eindeutigen Zusammenhang zwischen dieser und den Sprachen der
as"=Implementierungen zu haben, jedoch wäre dann die Äquivalenz zur \EIO{}
Sprach-Definition in~\cite{Schinko2016BA} verloren gegangen. Eine
Implementierung mit Fehler-Zuständen hätte dann auch eine Sprache mit Wörtern,
die sie nicht mal ausführen können muss.
